<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª: Ø£Ø­Ù…Ø± ÙˆØ£Ø³ÙˆØ¯</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Cairo', sans-serif;
            touch-action: none;
            user-select: none;
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        .player-indicator {
            transition: all 0.3s ease;
        }
        .active-p1 {
            transform: scale(1.05);
            box-shadow: 0 0 15px currentColor;
            opacity: 1 !important;
        }
        .active-p2 {
            transform: scale(1.05);
            box-shadow: 0 0 15px currentColor;
            opacity: 1 !important;
        }
        .sage-bubble {
            position: relative;
            background: #f0fdf4;
            border: 2px solid #22c55e;
            border-radius: 15px;
            padding: 15px;
            margin-top: 10px;
        }
        .sage-bubble::after {
            content: '';
            position: absolute;
            top: -10px;
            right: 20px;
            border-width: 0 10px 10px;
            border-style: solid;
            border-color: #22c55e transparent;
            display: block;
            width: 0;
        }
        .thinking-dots:after {
            content: '.';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }
        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3498db;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Style specifically for the dare box */
        .dare-box {
            background: repeating-linear-gradient(
              45deg,
              #fff,
              #fff 10px,
              #fdf2f8 10px,
              #fdf2f8 20px
            );
        }
    </style>
</head>
<body id="main-body" class="bg-gray-100 min-h-screen flex flex-col items-center justify-center overflow-y-auto py-4 transition-colors duration-500 text-gray-800">

    <!-- Header & Score -->
    <div class="w-full max-w-md px-4 mb-2">
        <div class="flex justify-between items-center mb-2 relative">
             <h1 id="game-title" class="text-2xl font-bold text-center flex-1">Ø­Ø±Ø¨ Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª</h1>
             <!-- Dark Mode Button -->
             <button onclick="toggleDarkMode()" class="absolute left-0 bg-gray-200 dark:bg-gray-700 p-2 rounded-full hover:bg-gray-300 transition shadow-sm" title="Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ">
                <span id="dark-mode-icon">ğŸŒ™</span>
             </button>
        </div>
        
        <!-- Game Mode & Sound Toggles -->
        <div class="flex justify-center gap-4 mb-3">
             <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="ai-toggle" class="sr-only peer">
                <div class="relative w-11 h-6 bg-gray-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                <span id="ai-label" class="ms-3 text-sm font-medium">Ø¶Ø¯ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±</span>
            </label>
            <button onclick="toggleSound()" id="sound-btn" class="text-gray-600 hover:text-blue-600">
                <svg id="sound-icon-on" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"></path></svg>
                <svg id="sound-icon-off" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"></path></svg>
            </button>
        </div>

        <!-- THEME GENERATOR INPUT -->
        <div class="flex gap-2 mb-4 bg-white p-2 rounded-lg shadow-sm border border-gray-200" id="theme-box">
            <input type="text" id="theme-input" placeholder="Ø§ÙƒØªØ¨ Ø«ÙŠÙ…Ø§Ù‹ (Ù…Ø«Ù„Ø§Ù‹: ÙØ¶Ø§Ø¡ØŒ ØºØ§Ø¨Ø©)..." class="flex-1 text-sm p-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500 text-right text-gray-800">
            <button onclick="generateTheme()" id="theme-btn" class="bg-gradient-to-r from-pink-500 to-orange-400 text-white text-xs font-bold px-3 rounded hover:opacity-90 transition flex items-center gap-1">
                <span>ğŸ¨</span>
                <span id="theme-btn-text">ØªÙ„ÙˆÙŠÙ†</span>
            </button>
        </div>

        <div id="scoreboard" class="flex justify-between items-center bg-white p-4 rounded-2xl shadow-lg border border-gray-200 transition-colors duration-500 text-gray-800">
            <!-- P1 Player -->
            <div id="p1-panel" class="player-indicator flex flex-col items-center justify-center w-1/3 p-2 rounded-xl border border-transparent transition-colors duration-300">
                <span class="font-bold text-lg">Ø£Ù†Øª</span>
                <span id="score-red" class="text-3xl font-bold">0</span>
            </div>

            <!-- Status Text -->
            <div class="flex flex-col items-center w-1/3">
                <span id="turn-text" class="text-sm mb-1 opacity-70">Ø§Ù„Ø¯ÙˆØ±</span>
                <div id="turn-indicator" class="w-8 h-8 rounded-full shadow-md transition-colors duration-300"></div>
            </div>

            <!-- P2 Player -->
            <div id="p2-panel" class="player-indicator flex flex-col items-center justify-center w-1/3 p-2 rounded-xl border border-transparent transition-colors duration-300">
                <span id="black-name" class="font-bold text-lg">Ø§Ù„Ø®ØµÙ…</span>
                <span id="score-black" class="text-3xl font-bold">0</span>
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <div id="canvas-container" class="relative bg-white rounded-xl shadow-xl p-2 border border-gray-200 mt-2 transition-colors duration-500">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Winner Overlay -->
        <div id="winner-overlay" class="hidden absolute inset-0 bg-white/95 z-10 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm transition-all duration-500 p-4 text-center">
            <h2 id="winner-text" class="text-4xl font-bold mb-2 text-gray-800">ÙØ§Ø² Ø§Ù„Ø£Ø­Ù…Ø±!</h2>
            
            <!-- Winner's Wish Section -->
            <div class="w-full max-w-xs mb-4 dare-box p-4 rounded-lg border-2 border-pink-200 shadow-inner">
                <h3 class="text-sm font-bold text-pink-600 mb-2">ğŸ‘‘ Ø£Ù…Ø± Ø§Ù„ÙØ§Ø¦Ø² (Ø­ÙƒÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ø³Ø±)</h3>
                
                <input type="text" id="wish-topic" placeholder="Ù†ÙˆØ¹ Ø§Ù„Ø­ÙƒÙ… (Ù…Ø«Ù„Ø§Ù‹: ØºÙ†Ø§Ø¡ØŒ Ø±ÙŠØ§Ø¶Ø©ØŒ Ù†ÙƒØªØ©)..." class="w-full text-sm p-2 mb-2 border border-pink-300 rounded focus:outline-none focus:border-pink-500 text-right text-gray-800 bg-white/80">
                
                <p id="wish-text" class="text-gray-700 text-lg font-bold min-h-[3rem] flex items-center justify-center mb-2">
                    Ø§ÙƒØªØ¨ Ù†ÙˆØ¹ Ø§Ù„Ø­ÙƒÙ… ÙˆØ§Ø¶ØºØ· Ø§Ù„Ø²Ø± ğŸ‘‡
                </p>
                
                <button onclick="generateWish()" id="wish-btn" class="w-full text-sm bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-600 hover:to-rose-600 text-white font-bold py-2 px-4 rounded-full shadow transition transform active:scale-95">
                    âš–ï¸ Ø£ØµØ¯Ø± Ø§Ù„Ø­ÙƒÙ… ÙŠØ§ ÙØ§Ø¦Ø²!
                </button>
            </div>

            <div class="flex flex-col gap-2 w-full max-w-xs">
                <button onclick="resetGame()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition hover:scale-105 active:scale-95 w-full">
                    Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©
                </button>
                <button onclick="consultSage('victory')" class="text-purple-600 font-bold hover:underline flex items-center justify-center gap-1 text-sm mt-2">
                    <span>âœ¨</span> Ù…Ø§Ø°Ø§ ÙŠÙ‚ÙˆÙ„ Ø§Ù„Ø­ÙƒÙŠÙ…ØŸ
                </button>
            </div>
        </div>
    </div>

    <!-- AI Sage Section -->
    <div class="w-full max-w-md px-4 mt-4">
        <button onclick="consultSage('commentary')" id="sage-btn" class="w-full bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700 text-white font-bold py-2 px-4 rounded-xl shadow-md transition transform active:scale-95 flex items-center justify-center gap-2">
            <span class="text-xl">ğŸ§™â€â™‚ï¸</span> Ø§Ø³ØªØ´Ø± Ø§Ù„Ø­ÙƒÙŠÙ… Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ
        </button>
        
        <div id="sage-response-area" class="hidden mt-2">
            <div class="sage-bubble shadow-sm" id="sage-bubble-el">
                <div class="flex items-start gap-3">
                    <div class="bg-purple-100 p-2 rounded-full min-w-[40px] text-center text-xl">ğŸ’¬</div>
                    <div>
                        <p class="font-bold text-gray-800 text-sm mb-1">Ø§Ù„Ø­ÙƒÙŠÙ… ÙŠÙ‚ÙˆÙ„:</p>
                        <p id="sage-text" class="text-gray-700 text-sm leading-relaxed">...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="mt-6 flex gap-4 mb-8">
        <button onclick="undoMove()" id="undo-btn" class="flex items-center gap-2 text-gray-700 bg-white hover:bg-yellow-50 py-2 px-6 rounded-lg shadow border border-gray-200 transition disabled:opacity-50 disabled:cursor-not-allowed">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            ØªØ±Ø§Ø¬Ø¹
        </button>
        <button onclick="resetGame()" class="flex items-center gap-2 text-red-600 bg-white hover:bg-red-50 py-2 px-6 rounded-lg shadow border border-gray-200 transition">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
            Ø¥Ø¹Ø§Ø¯Ø©
        </button>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreRedEl = document.getElementById('score-red');
        const scoreBlackEl = document.getElementById('score-black');
        const p1Panel = document.getElementById('p1-panel');
        const p2Panel = document.getElementById('p2-panel');
        const turnIndicator = document.getElementById('turn-indicator');
        const winnerOverlay = document.getElementById('winner-overlay');
        const winnerText = document.getElementById('winner-text');
        const aiToggle = document.getElementById('ai-toggle');
        const undoBtn = document.getElementById('undo-btn');
        const blackNameEl = document.getElementById('black-name');
        const wishText = document.getElementById('wish-text');
        const wishBtn = document.getElementById('wish-btn');
        const wishTopicInput = document.getElementById('wish-topic');
        
        // Theme Elements
        const mainBody = document.getElementById('main-body');
        const canvasContainer = document.getElementById('canvas-container');
        const scoreboard = document.getElementById('scoreboard');
        const gameTitle = document.getElementById('game-title');
        const aiLabel = document.getElementById('ai-label');
        const turnText = document.getElementById('turn-text');
        const themeBtn = document.getElementById('theme-btn');
        const themeInput = document.getElementById('theme-input');
        const themeBtnText = document.getElementById('theme-btn-text');
        const themeBox = document.getElementById('theme-box');

        // Sage Elements
        const sageBtn = document.getElementById('sage-btn');
        const sageResponseArea = document.getElementById('sage-response-area');
        const sageText = document.getElementById('sage-text');
        const sageBubble = document.getElementById('sage-bubble-el');
        
        // Gemini API Configuration
        const apiKey = "AIzaSyB3NC7YCpb9XqlflOFWDglSzDHIwF-36dU"; // Will be injected by runtime
        
        // Audio Context
        let audioCtx = null;
        let soundEnabled = true;

        // Game Configuration
        const DOT_RADIUS = 7;
        const CLICK_TOLERANCE = 25;
        let GRID_SIZE = 50; 
        
        // Default Theme (Light)
        const lightTheme = {
            p1: '#ef4444', 
            p2: '#171717', 
            bg: '#f3f4f6', 
            canvasBg: '#ffffff',
            dots: '#9ca3af',
            text: '#1f2937'
        };

        // Dark Theme
        const darkTheme = {
            p1: '#ef4444', 
            p2: '#000000', // Black lines
            bg: '#111827', // Gray 900
            canvasBg: '#cbd5e1', // Slate 300 (Light enough for black lines)
            dots: '#475569', 
            text: '#f3f4f6'
        };

        let currentTheme = lightTheme;
        let isDarkMode = false;

        // Game State
        let dots = [];
        let lines = []; 
        let triangles = []; 
        let currentPlayer = 'red'; 
        let selectedDotIndex = -1;
        let scores = { red: 0, black: 0 };
        let isGameOver = false;
        let isAIEnabled = false;
        let isAITurn = false;
        
        // History for Undo
        let historyStack = [];

        // --- DARK MODE TOGGLE ---
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            if (isDarkMode) {
                applyTheme(darkTheme);
                document.getElementById('dark-mode-icon').innerText = 'â˜€ï¸';
                themeBox.classList.add('opacity-50', 'pointer-events-none'); 
            } else {
                applyTheme(lightTheme);
                document.getElementById('dark-mode-icon').innerText = 'ğŸŒ™';
                themeBox.classList.remove('opacity-50', 'pointer-events-none');
            }
        }

        // --- GEMINI WISH GENERATOR (UPDATED) ---
        async function generateWish() {
             if (!apiKey) {
                wishText.innerText = "API Key missing!";
                return;
            }

            const topic = wishTopicInput.value.trim();
            wishBtn.disabled = true;
            wishText.innerHTML = '<span class="thinking-dots">Ø¬Ø§Ø±ÙŠ ØµÙŠØ§ØºØ© Ø§Ù„Ø­ÙƒÙ…</span>';

            let prompt = `
            Ø¨ØµÙØªÙŠ Ø§Ù„ÙØ§Ø¦Ø² ÙÙŠ Ù„Ø¹Ø¨Ø©ØŒ Ø£Ø±ÙŠØ¯ Ø­ÙƒÙ…Ø§Ù‹ Ù…Ø¶Ø­ÙƒØ§Ù‹ ÙˆØ·Ø±ÙŠÙØ§Ù‹ Ù„Ø£Ù†ÙØ°Ù‡ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ø³Ø±.
            `;
            
            if (topic) {
                prompt += ` Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø°ÙŠ Ø§Ø®ØªØ±ØªÙ‡ Ù‡Ùˆ: "${topic}". Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø­ÙƒÙ… Ù…ØªØ¹Ù„Ù‚Ø§Ù‹ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹.`;
            } else {
                prompt += ` Ø§Ø®ØªØ± Ù…ÙˆØ¶ÙˆØ¹Ø§Ù‹ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹ Ù…Ø¶Ø­ÙƒØ§Ù‹ (Ù…Ø«Ù„ Ø§Ù„ØºÙ†Ø§Ø¡ØŒ Ø§Ù„Ø±ÙŠØ§Ø¶Ø©ØŒ Ø§Ù„Ø§Ø¹ØªØ±Ø§Ù Ø¨Ø´ÙŠØ¡ Ù…Ø¶Ø­Ùƒ).`;
            }

            prompt += `
            Ø§Ù„Ø´Ø±ÙˆØ·: Ø¬Ù…Ù„Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·ØŒ Ø¨ØµÙŠØºØ© Ø§Ù„Ø£Ù…Ø± (Ù…Ø«Ù„Ø§Ù‹: "Ù‚Ù… Ø¨Ù€..." Ø£Ùˆ "Ù‚Ù„..."). Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                wishText.innerText = text;
            } catch (error) {
                wishText.innerText = "Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø®Ø§Ø³Ø± ÙŠØ¨ØªØ³Ù… Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§! ğŸ˜„";
            } finally {
                wishBtn.disabled = false;
                wishBtn.innerText = "ğŸ”„ Ø­ÙƒÙ… Ø¢Ø®Ø±";
            }
        }


        // --- GEMINI THEME GENERATOR ---
        
        async function generateTheme() {
            const promptText = themeInput.value.trim();
            if (!promptText) return;
            if (!apiKey) { alert("API Key missing"); return; }
            if (isDarkMode) toggleDarkMode(); 

            themeBtn.disabled = true;
            themeBtnText.innerText = "";
            const loader = document.createElement('div');
            loader.className = "loader";
            themeBtn.appendChild(loader);

            const systemPrompt = `
            You are a creative UI theme generator. Generate a JSON object for the game colors.
            Keys: bg (page background), canvasBg (game board), p1 (player 1 color), p2 (player 2 color), dots (dot color), text (text color).
            Ensure high contrast. Return raw JSON only.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `Theme description: ${promptText}` }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                const data = await response.json();
                const newTheme = JSON.parse(data.candidates[0].content.parts[0].text);
                applyTheme(newTheme);
            } catch (e) {
                console.error(e);
            } finally {
                themeBtn.removeChild(loader);
                themeBtnText.innerText = "ØªÙ„ÙˆÙŠÙ†";
                themeBtn.disabled = false;
            }
        }

        function applyTheme(theme) {
            currentTheme = theme;
            
            mainBody.style.backgroundColor = theme.bg;
            mainBody.style.color = theme.text;
            
            gameTitle.style.color = theme.text;
            aiLabel.style.color = theme.text;
            
            scoreboard.style.backgroundColor = theme.canvasBg;
            scoreboard.style.color = theme.text;
            turnText.style.color = theme.text;
            
            canvasContainer.style.backgroundColor = theme.canvasBg;
            canvas.style.backgroundColor = theme.canvasBg;
            
            // Re-render
            draw();
            updateUI();
        }

        // --- GEMINI SAGE ---
        
        async function consultSage(mode) {
            if (!apiKey) return;

            sageResponseArea.classList.remove('hidden');
            sageText.innerHTML = '<span class="thinking-dots">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙÙƒÙŠØ±</span>';
            sageBtn.disabled = true;
            sageBtn.classList.add('opacity-50');

            sageBubble.style.borderColor = currentTheme.p1;
            sageBubble.style.background = isDarkMode ? '#1f2937' : '#f0fdf4';
            sageText.style.color = isDarkMode ? '#f3f4f6' : '#374151';

            let prompt = "";
            if (mode === 'victory') {
                const winner = scores.red > scores.black ? "Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£ÙˆÙ„" : "Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø«Ø§Ù†ÙŠ";
                prompt = `Ø£Ù†Øª Ù…Ø¹Ù„Ù‚ Ø­ÙƒÙŠÙ…. Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù†ØªÙ‡Øª Ø¨ÙÙˆØ² ${winner}. Ø¹Ù„Ù‘Ù‚ Ø¨Ø§Ø®ØªØµØ§Ø± Ø´Ø¯ÙŠØ¯ ÙˆÙ…Ø¶Ø­Ùƒ.`;
            } else {
                prompt = `Ø£Ù†Øª Ù…Ø¹Ù„Ù‚ Ø­ÙƒÙŠÙ… ÙÙŠ Ù„Ø¹Ø¨Ø© Ù…Ø«Ù„Ø«Ø§Øª. Ø§Ù„Ù†ØªÙŠØ¬Ø©: P1=${scores.red}, P2=${scores.black}. Ø§Ù„Ø¯ÙˆØ± Ù„Ù€: ${currentPlayer}. Ø¹Ù„Ù‘Ù‚ Ø¨Ø¬Ù…Ù„Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø¶Ø­ÙƒØ© Ø¨Ø§Ù„Ù„Ù‡Ø¬Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.`;
            }

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                const data = await response.json();
                sageText.innerText = data.candidates[0].content.parts[0].text;
            } catch (error) {
                sageText.innerText = "ğŸ˜´";
            } finally {
                sageBtn.disabled = false;
                sageBtn.classList.remove('opacity-50');
            }
        }

        // --- CORE GAME ---

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playTone(freq, type, duration) {
            if (!soundEnabled || !audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playSound(action) {
            initAudio();
            if (action === 'select') playTone(400, 'sine', 0.1);
            if (action === 'connect') playTone(600, 'triangle', 0.1);
            if (action === 'score') { playTone(800, 'sine', 0.1); setTimeout(() => playTone(1200, 'square', 0.2), 100); }
            if (action === 'win') { playTone(500, 'sine', 0.2); }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-icon-on').classList.toggle('hidden');
            document.getElementById('sound-icon-off').classList.toggle('hidden');
        }

        function resizeCanvas() {
            const containerWidth = Math.min(window.innerWidth - 32, 500); 
            const containerHeight = containerWidth; 
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            GRID_SIZE = containerWidth / 7; 
            initDots();
            draw();
        }

        function initDots() {
            dots = [];
            const rows = 6;
            for (let r = 0; r < rows; r++) {
                const y = 50 + r * (GRID_SIZE * 0.866);
                const xOffset = (r % 2) * (GRID_SIZE / 2);
                for (let c = 0; c < 5; c++) {
                   if(r === 0 && c === 4) continue;
                   if(r === 0 && c === 0) continue;
                   if(r === 5 && c === 0) continue;
                   if(r === 5 && c === 4) continue;
                   const x = 50 + c * GRID_SIZE + xOffset + (canvas.width - (5 * GRID_SIZE))/2 - 25; 
                   dots.push({ x, y, id: dots.length });
                }
            }
        }

        function saveState() {
            const state = {
                lines: JSON.parse(JSON.stringify(lines)),
                triangles: JSON.parse(JSON.stringify(triangles)),
                currentPlayer: currentPlayer,
                scores: { ...scores }
            };
            historyStack.push(state);
            if (historyStack.length > 50) historyStack.shift();
            undoBtn.disabled = false;
        }

        function undoMove() {
            if (historyStack.length === 0 || isGameOver || isAITurn) return;
            const state = historyStack.pop();
            lines = state.lines;
            triangles = state.triangles;
            currentPlayer = state.currentPlayer;
            scores = state.scores;
            selectedDotIndex = -1;
            isGameOver = false;
            winnerOverlay.classList.add('hidden');
            undoBtn.disabled = historyStack.length === 0;
            updateUI();
            draw();
        }

        function resetGame() {
            lines = [];
            triangles = [];
            historyStack = [];
            currentPlayer = 'red';
            selectedDotIndex = -1;
            scores = { red: 0, black: 0 };
            isGameOver = false;
            isAITurn = false;
            isAIEnabled = aiToggle.checked;
            blackNameEl.innerText = isAIEnabled ? "Ø§Ù„Ø®ØµÙ…" : "Ø§Ù„Ø®ØµÙ…";
            winnerOverlay.classList.add('hidden');
            sageResponseArea.classList.add('hidden');
            
            // Reset wish box
            wishTopicInput.value = "";
            wishText.innerText = "Ø§ÙƒØªØ¨ Ù†ÙˆØ¹ Ø§Ù„Ø­ÙƒÙ… ÙˆØ§Ø¶ØºØ· Ø§Ù„Ø²Ø± ğŸ‘‡";
            wishBtn.innerText = "âš–ï¸ Ø£ØµØ¯Ø± Ø§Ù„Ø­ÙƒÙ… ÙŠØ§ ÙØ§Ø¦Ø²!";
            wishBtn.disabled = false;
            
            initDots();
            updateUI();
            undoBtn.disabled = true;
            draw();
        }

        function addLine(idx1, idx2) {
            const p1 = Math.min(idx1, idx2);
            const p2 = Math.max(idx1, idx2);
            if (lines.some(l => (l.p1 === p1 && l.p2 === p2))) return false;

            const d1 = dots[p1], d2 = dots[p2];
            if (Math.hypot(d1.x - d2.x, d1.y - d2.y) > GRID_SIZE * 1.3) return false;

            saveState();
            lines.push({ p1, p2, color: currentPlayer });
            playSound('connect');
            
            const madeTriangle = checkForTriangles(p1, p2);
            if (madeTriangle) {
                playSound('score');
            } else {
                currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
            }

            selectedDotIndex = -1;
            updateUI();
            draw();
            
            if (isAIEnabled && currentPlayer === 'black' && !isGameOver) {
                isAITurn = true;
                setTimeout(aiMove, 600);
            }
            return true;
        }

        function aiMove() {
            if (isGameOver || currentPlayer !== 'black') { isAITurn = false; return; }

            let bestMove = null;
            let validMoves = [];
            for (let i = 0; i < dots.length; i++) {
                for (let j = i + 1; j < dots.length; j++) {
                    const dist = Math.hypot(dots[i].x - dots[j].x, dots[i].y - dots[j].y);
                    if (dist < GRID_SIZE * 1.3 && !lines.some(l => l.p1 === i && l.p2 === j)) {
                         validMoves.push({p1: i, p2: j});
                    }
                }
            }

            if (validMoves.length === 0) return;

            for (let move of validMoves) {
                for (let k = 0; k < dots.length; k++) {
                    if (k === move.p1 || k === move.p2) continue;
                    const l1 = lines.some(l => (l.p1 === Math.min(move.p1, k) && l.p2 === Math.max(move.p1, k)));
                    const l2 = lines.some(l => (l.p1 === Math.min(move.p2, k) && l.p2 === Math.max(move.p2, k)));
                    if (l1 && l2) { bestMove = move; break; }
                }
                if (bestMove) break;
            }

            if (!bestMove) bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            
            addLine(bestMove.p1, bestMove.p2);
            
            if (currentPlayer === 'black' && !isGameOver) setTimeout(aiMove, 600);
            else isAITurn = false;
        }

        function checkForTriangles(newP1, newP2) {
            let found = false;
            for (let k = 0; k < dots.length; k++) {
                if (k === newP1 || k === newP2) continue;
                const hasLine1 = lines.some(l => (l.p1 === Math.min(newP1, k) && l.p2 === Math.max(newP1, k)));
                const hasLine2 = lines.some(l => (l.p1 === Math.min(newP2, k) && l.p2 === Math.max(newP2, k)));

                if (hasLine1 && hasLine2) {
                    const p1 = Math.min(newP1, newP2, k);
                    const p3 = Math.max(newP1, newP2, k);
                    const p2 = (newP1 + newP2 + k) - p1 - p3;
                    if (!triangles.some(t => t.p1 === p1 && t.p2 === p2 && t.p3 === p3)) {
                        triangles.push({ p1, p2, p3, color: currentPlayer });
                        scores[currentPlayer]++;
                        found = true;
                    }
                }
            }
            return found;
        }

        function updateUI() {
            scoreRedEl.innerText = scores.red;
            scoreBlackEl.innerText = scores.black;

            p1Panel.style.borderColor = currentPlayer === 'red' ? currentTheme.p1 : 'transparent';
            p2Panel.style.borderColor = currentPlayer === 'black' ? currentTheme.p2 : 'transparent';
            
            if (currentPlayer === 'red') {
                p1Panel.classList.add('active-p1');
                p1Panel.classList.remove('opacity-50');
                p2Panel.classList.remove('active-p2');
                p2Panel.classList.add('opacity-50');
                p1Panel.style.color = currentTheme.p1;
                turnIndicator.style.backgroundColor = currentTheme.p1;
            } else {
                p2Panel.classList.add('active-p2');
                p2Panel.classList.remove('opacity-50');
                p1Panel.classList.remove('active-p1');
                p1Panel.classList.add('opacity-50');
                p2Panel.style.color = currentTheme.p2;
                turnIndicator.style.backgroundColor = currentTheme.p2;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            triangles.forEach(t => {
                const d1 = dots[t.p1], d2 = dots[t.p2], d3 = dots[t.p3];
                ctx.beginPath();
                ctx.moveTo(d1.x, d1.y);
                ctx.lineTo(d2.x, d2.y);
                ctx.lineTo(d3.x, d3.y);
                ctx.closePath();
                const baseColor = t.color === 'red' ? currentTheme.p1 : currentTheme.p2;
                ctx.fillStyle = baseColor;
                ctx.globalAlpha = 0.4; 
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            lines.forEach(l => {
                const d1 = dots[l.p1], d2 = dots[l.p2];
                ctx.beginPath();
                ctx.moveTo(d1.x, d1.y);
                ctx.lineTo(d2.x, d2.y);
                ctx.strokeStyle = l.color === 'red' ? currentTheme.p1 : currentTheme.p2;
                ctx.stroke();
            });

            dots.forEach((dot, index) => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
                
                if (index === selectedDotIndex) {
                    ctx.fillStyle = currentPlayer === 'red' ? currentTheme.p1 : currentTheme.p2;
                    ctx.shadowColor = currentPlayer === 'red' ? currentTheme.p1 : currentTheme.p2;
                    ctx.shadowBlur = 15;
                } else {
                    ctx.fillStyle = currentTheme.dots; 
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function handleInput(e) {
            if (isGameOver || (isAIEnabled && currentPlayer === 'black')) return;
            const rect = canvas.getBoundingClientRect();
            let clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            let clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            let clickedDotIndex = -1;
            for (let i = 0; i < dots.length; i++) {
                if (Math.hypot(x - dots[i].x, y - dots[i].y) < CLICK_TOLERANCE) { clickedDotIndex = i; break; }
            }

            if (clickedDotIndex !== -1) {
                if (selectedDotIndex === -1) {
                    selectedDotIndex = clickedDotIndex;
                    playSound('select');
                } else if (selectedDotIndex === clickedDotIndex) {
                    selectedDotIndex = -1;
                } else {
                    const success = addLine(selectedDotIndex, clickedDotIndex);
                    if (!success) {
                        if (Math.hypot(dots[selectedDotIndex].x - dots[clickedDotIndex].x, dots[selectedDotIndex].y - dots[clickedDotIndex].y) > GRID_SIZE * 1.5) {
                            selectedDotIndex = clickedDotIndex;
                            playSound('select');
                        }
                    }
                }
                draw();
            } else {
                selectedDotIndex = -1;
                draw();
            }
        }

        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput, {passive: false});
        aiToggle.addEventListener('change', resetGame);
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        updateUI();
    </script>
</body>
</html>

